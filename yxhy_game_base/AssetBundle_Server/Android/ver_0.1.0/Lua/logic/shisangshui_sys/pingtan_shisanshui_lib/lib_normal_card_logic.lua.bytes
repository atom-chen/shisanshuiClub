local LibBase = import(".lib_base")
local LibLaiZi = import(".lib_laizi"):create()
local LibNormalCardLogic = class("LibNormalCardLogic", LibBase)

function LibNormalCardLogic:ctor()
end

function LibNormalCardLogic:CreateInit(strSlotName)
    return true
end

function LibNormalCardLogic:OnGameStart()
end

--移除
function LibNormalCardLogic:RemoveCard(srcCards, rmCards)
    if type(srcCards) ~= "table" then
        return
    end
    if type(rmCards) ~= "table" then
        return
    end
    if #srcCards == 0 or #rmCards == 0 then
        return
    end

    for _, v in ipairs(rmCards) do
        Array.RemoveOne(srcCards, v)
    end
end

--按值升序 2-14(A)
function LibNormalCardLogic:Sort(cards)
    -- LOG_DEBUG("LibNormalCardLogic:Sort..before, cards: %s\n", TableToString(cards))
    if not cards.isSorted then
        table.sort(cards, function(a,b)
            local valueA,colorA = GetCardValue(a), GetCardColor(a)
            local valueB,colorB = GetCardValue(b), GetCardColor(b)
            if valueA == valueB then
                return colorA < colorB
            else
                return valueA < valueB
            end
        end)
        cards.isSorted = true
    end
    -- LOG_DEBUG("LibNormalCardLogic:Sort..end, cards: %s\n", TableToString(cards))
end
--分花色排序 花色相同按值升序
function LibNormalCardLogic:Sort_By_Color(cards)
    -- LOG_DEBUG("LibNormalCardLogic:Sort_By_Color..before, cards: %s\n", TableToString(cards))
    table.sort(cards, function(a,b)
        local valueA,colorA = GetCardValue(a), GetCardColor(a)
        local valueB,colorB = GetCardValue(b), GetCardColor(b)
        if colorA == colorB then
            return valueA < valueB
        else
            return colorA < colorB
        end
    end)
    cards.isSorted = false
    -- LOG_DEBUG("LibNormalCardLogic:Sort_By_Color..end, cards: %s\n", TableToString(cards))
end
--按值排序  从小到大
function LibNormalCardLogic:Sort_By_Value(values)
    if not values.isSorted then
        table.sort(values, function(a, b)
            return a < b
        end)
        values.isSorted = true
    end
end

--有几张不同点数的牌
function LibNormalCardLogic:Uniqc(cards)
    self:Sort(cards)
    local n, uniq, val = 0, 0, 0
    for _,v in ipairs(cards) do
        val = GetCardValue(v)
        if val ~= uniq then
            uniq = val
            n = n + 1
        end
    end
    return n
end

--是否是同花
function LibNormalCardLogic:IsFlush(cards)
    if #cards == 0 then
        return false
    end
    -- LOG_DEBUG("LibNormalCardLogic:IsFlush.., cards: %s\n", TableToString(cards))

    local color = GetCardColor(cards[1])
    for i=2, #cards do
        if color ~= GetCardColor(cards[i]) then
            return false
        end
    end
    return true
end

-- 是否顺子 普通情况
function LibNormalCardLogic:IsStraight_Common(cards)
    self:Sort(cards)
    local nLen = #cards
    local a1, an = GetCardValue(cards[1]), GetCardValue(cards[nLen])
    if an - a1 ~= nLen - 1 then
        return false
    end
    local a = a1
    for i=2, nLen do
        local rank = GetCardValue(cards[i])
        if rank-a ~= 1 then
            return false
        end
        a = rank
    end
    return true
end

--是否是顺子(A值是1的情况) 2 3 4 5 A
function LibNormalCardLogic:IsStraight(cards)
    self:Sort(cards)
    local nLen = #cards
    local a1, an = GetCardValue(cards[1]), GetCardValue(cards[nLen])
    if a1 ~= 2 or an ~= 14 then
        return self:IsStraight_Common(cards)
    else
        local a = a1
        for i=2, nLen-1 do
            local rank = GetCardValue(cards[i])
            if rank-a ~= 1 then
                return false
            end
            a = rank
        end
        return true
    end
end

--返回>=nSameCoun的牌值 返回val, count
function LibNormalCardLogic:GetSameValue(values, nSameCount)
    local hash = {}
    for i=1, 15 do
        hash[i] = 0
    end
    for _, val in ipairs(values) do
        hash[val] = hash[val] + 1
    end

    for val, count in ipairs(hash) do
        if count >= nSameCount then
            return val, count
        end
    end
    return 0,0       
end

--返回值0表示没对子, 值是按从小到大返回的
function LibNormalCardLogic:GetPairValue(cards)
    self:Sort(cards)
    local ret = {}
    local tempVal = nil
    for _, v in ipairs(cards) do
        local val = GetCardValue(v)
        if tempVal == val and ret[#ret] ~= val then
            table.insert(ret, val)
        else
            tempVal = val
        end
    end

    -- LOG_DEBUG("LibNormalCardLogic:GetPairValue..ret: %s\n", vardump(ret))
    --return table.unpack(ret)
    return (ret[1] or 0), (ret[2] or 0)
end

--比较散牌：从大到小 一对一比较
function LibNormalCardLogic:CompareSingle(cardsA, cardsB)
    if #cardsA == 0 and #cardsB == 0 then
        return 0
    elseif #cardsA == 0 then
        return -1
    elseif #cardsB == 0 then
        return 1
    end

    self:Sort(cardsA)
    self:Sort(cardsB)

    local va = GetCardValue(cardsA[#cardsA])
    local vb = GetCardValue(cardsB[#cardsB])
    local n = va - vb
    if n ~= 0 then
        return n
    else
        table.remove(cardsA)
        table.remove(cardsB)
        return self:CompareSingle(cardsA, cardsB) 
    end
end

--获取牌值相同的数量 最多5张
function LibNormalCardLogic:GetLarge2SameCard(cards)
    local one,two,three,four,five = 0,0,0,0,0
    local values = {}
    for i=1, 14 do
        values[i] = 0
    end
    for _, v in ipairs(cards) do
        local val = GetCardValue(v)
        values[val] = values[val] + 1
    end
    for val, count in ipairs(values) do
        if count == 1 then
            one = one + 1
        elseif count == 2 then
            two = two + 1
        elseif count == 3 then
            three = three + 1
        elseif count == 4 then
            four = four + 1
        elseif count >= 5 then
            five = five + 1
        end
    end

    return one,two,three,four,five
end

--================================================================
--癞子版顺子
function LibNormalCardLogic:IsStraight_Laizi(cards, nLaiziCount)
    local bFind = true
    local tempLZCount = nLaiziCount

    if nLaiziCount == 0 then
        bFind = self:IsStraight(cards)
    else
        if #cards == 0 then
            return true, 0
        end

        self:Sort(cards)
        local nLen = #cards
        local a1 = GetCardValue(cards[1])
        local an = GetCardValue(cards[nLen])

        local a = a1

        --普通顺子
        for i=2, nLen do
            local rank = GetCardValue(cards[i])
            if rank-a > 1 then
                local nSub = rank - a -1
                if nSub <= tempLZCount then
                    tempLZCount = tempLZCount - nSub
                else
                    bFind = false
                    break
                end
            elseif rank-a <= 0 then
                bFind = false
                break
            end
            a = rank
        end

        --A顺
        if bFind == false then
            if an == 14 then
                a = 1
            end
            bFind = true
            for i=1, nLen-1 do
                local rank = GetCardValue(cards[i])
                if rank-a > 1 then
                    local nSub = rank - a -1
                    if nSub <= tempLZCount then
                        tempLZCount = tempLZCount - nSub
                    else
                        bFind = false
                        break
                    end
                 elseif rank-a <= 0 then
                    bFind = false
                    break
                end
                a = rank
            end 
        end
    end

   return bFind, tempLZCount
end

--牌值 花色 分离
function LibNormalCardLogic:CardsChange(cards)
    local stColorValue = {}
    for i=0, 4 do
        if stColorValue[i] == nil then
            stColorValue[i] = {}
        end
        for j=0, 14 do
            stColorValue[i][j] = 0
        end
    end

    for _, v in pairs(cards) do
        local color = GetCardColor(v)
        local value = GetCardValue(v)
        --[color][value] = count
        stColorValue[color][value] = stColorValue[color][value] + 1
        --[color][0] = count 花色数量
        stColorValue[color][0] = stColorValue[color][0] + 1
        --[4][value] = count 点数数量
        stColorValue[4][value] = stColorValue[4][value] + 1
    end

    return stColorValue
end

--获取顺子 5张
function LibNormalCardLogic:GetStraight_Laizi(values, nLaiziCount)
    local t = {}
    local bFind = false
    --找所有能组成顺子 A2345,23456。。。10JQKA
    local bHasAShun = false
    local bHasKShun = false
    local stAShun = {}
    local stKShun = {}
    for i=1, 10 do
        local tempLZCount = nLaiziCount
        local straight = true
        local temp = {}
        for j=1, 5 do
            local nV = i+j-1
            if values[nV] == 0 then
                if tempLZCount > 0 then
                    if nV == 1 then
                        nV = 14
                    end
                    table.insert(temp, nV)
                    tempLZCount = tempLZCount -1
                else
                    straight = false
                    break
                end 
            else
                if nV == 1 then
                    nV = 14
                end
                table.insert(temp, nV)
            end 
        end
        if straight then
            -- local cardType = GStars_Normal_Type_SSS.PT_STRAIGHT_FLUSH
            bFind = true
            if i == 1 then
                bHasAShun = true
                stAShun = temp
            elseif i == 10 then
                bHasKShun = true
                stKShun = temp 
            else
                table.insert(t, temp)
            end
        end
    end
    --把最大的放最后
    if bHasAShun then
        table.insert(t, stAShun)
    end
    if bHasKShun then
        table.insert(t, stKShun)
    end
    return bFind, t
end

--获取同花 5张
function LibNormalCardLogic:GetFlush_Laizi(values, nLaiziCount)
    local t = {}
    local bFind = false
    for i=14, 2, -1 do
        local temp = {}
        local tempLZCount = nLaiziCount
        if values[i] > 0 then
            if values[i] == 2 then
                for k=1, values[i] do
                    table.insert(temp, i)
                end
            elseif values[i] == 1 then
                table.insert(temp, i)
                if tempLZCount > 0 then
                    table.insert(temp, i)
                    tempLZCount = tempLZCount - 1
                end
            end
            if #temp < 5 then
                for j=i-1, 2, -1 do
                    if values[j] == 2 then
                        for k=1, values[j] do
                            table.insert(temp, j)
                        end
                    elseif values[j] == 1 then
                        table.insert(temp, j)
                        if tempLZCount > 0 then
                            table.insert(temp, j)
                            tempLZCount = tempLZCount - 1
                        end
                    end
                    if #temp == 5 then
                        bFind = true
                        table.insert(t, temp)
                        break
                    end
                end
            end
            --找到一个就退出了
            if bFind then
                break
            end
        end
    end

    return bFind, t 
end

--5张牌  获取最大的牌型及牌值
function LibNormalCardLogic:GetCardsAndTypeFive_Laizi(cards, nLaiziCount)
    local tempValues = {}
    local bFind = false
    --全是癞子
    if nLaiziCount >= 5 then
        local cardType = GStars_Normal_Type_SSS.PT_SIX
        bFind = true
        if tempValues[cardType] == nil then
            tempValues[cardType] = {}
        end
        table.insert(tempValues[cardType], {3, 3, 3, 3, 3})
    else
        local stColorValue = self:CardsChange(cards)
        for i=2, 14 do
            local nCount = stColorValue[4][i]   --点数数量
            if nCount > 0 then
                local nTotalSame = nCount + nLaiziCount
                if nTotalSame == 5 then
                    bFind = true
                    local cardType = GStars_Normal_Type_SSS.PT_FIVE
                    -- 22222 33333
                    if i == 2 or i == 3 then
                        cardType = GStars_Normal_Type_SSS.PT_SIX
                    end
                    if tempValues[cardType] == nil then
                        tempValues[cardType] = {}
                    end
                    --最大的放在最后
                    table.insert(tempValues[cardType], {i, i, i ,i, i})
                elseif nTotalSame == 4 then
                    local cardType = GStars_Normal_Type_SSS.PT_FOUR
                    for j=2, 14 do
                        if i ~= j and stColorValue[4][j] == 1 then
                            bFind = true
                            -- 2222+x 3333+x
                            if i == 2 or i == 3 then
                                cardType = GStars_Normal_Type_SSS.PT_FIVE
                            end
                            if tempValues[cardType] == nil then
                                tempValues[cardType] = {}
                            end
                            --最大的放在最后
                            table.insert(tempValues[cardType], {i, i, i, i, j})
                            break
                        end
                    end
                elseif nTotalSame == 3 then
                   --222/333+xy
                    if i == 2 or i == 3 then
                        local cardType = GStars_Normal_Type_SSS.PT_FOUR
                        if tempValues[cardType] == nil then
                            tempValues[cardType] = {}
                        end
                        bFind = true
                        local stAddValues = {}
                        table.insert(stAddValues, i)
                        table.insert(stAddValues, i)
                        table.insert(stAddValues, i)
                        for j=2, 14 do
                            local nj = stColorValue[4][j]
                            if i ~= j and nj > 0 then
                                for k=1, nj do
                                    table.insert(stAddValues, j)
                                end
                            end
                            if #stAddValues == 5 then
                                break
                            end
                        end
                        --最大的放在最后
                        table.insert(tempValues[cardType], stAddValues)
                    else
                        --葫芦 3条
                        for j=2, 14 do
                            if i ~= j and stColorValue[4][j] > 0 then
                                if stColorValue[4][j] == 2 then
                                    local cardType = GStars_Normal_Type_SSS.PT_FULL_HOUSE
                                    if tempValues[cardType] == nil then
                                        tempValues[cardType] = {}
                                    end
                                    bFind = true
                                    --最大的放在最后
                                    table.insert(tempValues[cardType], {i, i, i, j, j})
                                    break
                                elseif stColorValue[4][j] == 1 then
                                    local temp = {i, i, i, j}
                                    for k=j+1, 14 do
                                        if stColorValue[4][k] == 1 then
                                            table.insert(temp, k)
                                            break
                                        end
                                    end
                                    if #temp == 5 then
                                        local cardType = GStars_Normal_Type_SSS.PT_THREE
                                        if tempValues[cardType] == nil then
                                            tempValues[cardType] = {}
                                        end
                                        bFind = true
                                        table.insert(tempValues[cardType], temp)
                                        break
                                    end
                                end
                            end
                        end
                    end
                elseif nTotalSame == 2 then
                    --2对 1对
                    for j=2, 14 do
                        if i ~= j and stColorValue[4][j] > 0 then
                            if stColorValue[4][j] == 2 then
                                local temp = {i, i, j, j}
                                for k=j+1, 14 do
                                    if stColorValue[4][k] == 1 then
                                        table.insert(temp, k)
                                        break
                                    end
                                end
                                if #temp == 5 then
                                    local cardType = GStars_Normal_Type_SSS.PT_TWO_PAIR
                                    if tempValues[cardType] == nil then
                                        tempValues[cardType] = {}
                                    end
                                    bFind = true
                                    table.insert(tempValues[cardType], temp)
                                    break
                                end
                            elseif stColorValue[4][j] == 1 then
                                local temp = {i, i, j}
                                for k=j+1, 14 do
                                    if stColorValue[4][k] == 1 then
                                        table.insert(temp, k)
                                    end
                                    if #temp == 5 then
                                        break
                                    end
                                end
                                if #temp == 5 then
                                    local cardType = GStars_Normal_Type_SSS.PT_ONE_PAIR
                                    if tempValues[cardType] == nil then
                                        tempValues[cardType] = {}
                                    end
                                    bFind = true
                                    table.insert(tempValues[cardType], temp)
                                    break
                                end
                            end
                        end
                    end
                end
            end
        end
        --同花顺
        local bFlushStraight = false
        for i=0, 3 do
            local nCount = 0
            local values = {}
            for j=2, 14 do
                values[j] = stColorValue[i][j]
                if stColorValue[i][j] > 0 then
                    nCount = nCount + 1
                end
            end
            values[1] = values[14]
            --5张不同的点数才有可能 组合成同花顺
            local nTotalSame = nCount + nLaiziCount
            if nTotalSame == 5 then
                local bSuc, temp = self:GetStraight_Laizi(values, nLaiziCount)
                if bSuc then
                    bFind = true
                    bFlushStraight = true
                    local cardType = GStars_Normal_Type_SSS.PT_STRAIGHT_FLUSH
                    if tempValues[cardType] == nil then
                        tempValues[cardType] = {}
                    end
                    for _, v in ipairs(temp) do
                        table.insert(tempValues[cardType], v)
                    end
                end
            end
        end
        --同花
        if bFlushStraight == false then
            for i=0, 3 do
                local nCount = 0
                local values = {}
                for j=2, 14 do
                    values[j] = stColorValue[i][j]
                    if stColorValue[i][j] > 0 then
                        nCount = nCount + stColorValue[i][j]
                    end
                end
                local nTotalSame = nCount + nLaiziCount
                if nTotalSame == 5 then
                    local bSuc, temp = self:GetFlush_Laizi(values, nLaiziCount)
                    if bSuc then
                        bFind = true
                        bFlushStraight = true
                        local cardType = GStars_Normal_Type_SSS.PT_FLUSH
                        if tempValues[cardType] == nil then
                            tempValues[cardType] = {}
                        end
                        for _, v in ipairs(temp) do
                            table.insert(tempValues[cardType], v)
                        end
                    end
                end
            end
        end
        --顺子
        if bFlushStraight == false then
            local nCount = 0
            local values = {}
            for j=2, 14 do
                values[j] = stColorValue[4][j]
                if stColorValue[4][j] > 0 then
                    nCount = nCount + 1
                end
            end
            values[1] = values[14]
            local nTotalSame = nCount + nLaiziCount
            if nTotalSame == 5 then
                local bSuc, temp = self:GetStraight_Laizi(values, nLaiziCount)
                if bSuc then
                    bFind = true
                    local cardType = GStars_Normal_Type_SSS.PT_STRAIGHT
                    if tempValues[cardType] == nil then
                        tempValues[cardType] = {}
                    end
                    for _, v in ipairs(temp) do
                        table.insert(tempValues[cardType], v)
                    end
                end
            end
        end
        --散牌
        if bFind == false then
            local cardType = GStars_Normal_Type_SSS.PT_SINGLE
            bFind = true
            if tempValues[cardType] == nil then
                tempValues[cardType] = {}
            end
            local stAddValues = {}
            for j=2, 14 do
                local nj = stColorValue[4][j]
                if nj > 0 then
                    for k=1, nj do
                        table.insert(stAddValues, j)
                    end
                end
                if #stAddValues == 5 then
                    break
                end
            end
            table.insert(tempValues[cardType], stAddValues)
        end
    end
    return bFind, tempValues
end
--3张牌  获取最大的牌型及牌值
function LibNormalCardLogic:GetCardsAndTypeThree_Laizi(cards, nLaiziCount)
    local tempValues = {}
    local bFind = false
    --全是癞子
    if nLaiziCount >= 3 then
        local cardType = GStars_Normal_Type_SSS.PT_THREE_THREE
        bFind = true
        if tempValues[cardType] == nil then
            tempValues[cardType] = {}
        end
        table.insert(tempValues[cardType], {3, 3, 3})
    else
        local stColorValue = self:CardsChange(cards)
        for i=2, 14 do
            local nCount = stColorValue[4][i]
            if nCount > 0 then
                local nTotalSame = nCount + nLaiziCount
                if nTotalSame == 3 then
                    bFind = true
                    local cardType = GStars_Normal_Type_SSS.PT_THREE
                    local stAddValues = {}
                    --TODO:对222 333 对鬼冲前 做特殊处理
                    if i == 2 then
                        cardType = GStars_Normal_Type_SSS.PT_THREE_TWO
                        stAddValues = {i, i, i}
                    elseif i == 3 then
                        cardType = GStars_Normal_Type_SSS.PT_THREE_THREE
                        stAddValues = {i, i, i}
                    elseif nLaiziCount == 2 then
                        cardType = GStars_Normal_Type_SSS.PT_THREE_GHOST
                        stAddValues = {i, 15, 15}
                    else
                        stAddValues = {i, i, i}
                    end
                    if tempValues[cardType] == nil then
                        tempValues[cardType] = {}
                    end
                    table.insert(tempValues[cardType], stAddValues)
                elseif nTotalSame == 2 then
                    local cardType = GStars_Normal_Type_SSS.PT_ONE_PAIR
                    if tempValues[cardType] == nil then
                        tempValues[cardType] = {}
                    end
                    for j=2, 14 do
                        if i ~= j and stColorValue[4][j] > 0 then
                            bFind = true
                            --最大的放在最后了
                            table.insert(tempValues[cardType], {i, i, j})
                        end
                    end 
                end
            end
        end
        if bFind == false then
            local cardType = GStars_Normal_Type_SSS.PT_SINGLE
            bFind = true
            if tempValues[cardType] == nil then
                tempValues[cardType] = {}
            end
            local stAddValues = {}
            for j=2, 14 do
                local nj = stColorValue[4][j]
                if nj > 0 then
                    for k=1, nj do
                        table.insert(stAddValues, j)
                    end
                end
                if #stAddValues == 5 then
                    break
                end
            end
            table.insert(tempValues[cardType], stAddValues)
        end
    end
    return bFind, tempValues
end

--返回值0表示没对子, 值是按从小到大返回的
function LibNormalCardLogic:GetPairValueByValue(values)
    self:Sort_By_Value(values)
    local ret = {}
    local tempVal = nil
    for _, val in ipairs(values) do
        if tempVal == val and ret[#ret] ~= val then
            table.insert(ret, val)
        else
            tempVal = val
        end
    end

    -- LOG_DEBUG("LibNormalCardLogic:GetPairValueByValue..ret: %s\n", vardump(ret))
    return (ret[1] or 0), (ret[2] or 0)
end

--比较散牌：从大到小 一对一比较
function LibNormalCardLogic:CompareSingleByValue(valuesA, valuesB)
    if #valuesA == 0 and #valuesB == 0 then
        return 0
    elseif #valuesA == 0 then
        return -1
    elseif #valuesB == 0 then
        return 1
    end

    self:Sort_By_Value(valuesA)
    self:Sort_By_Value(valuesB)

    local va = valuesA[#valuesA] or 0
    local vb = valuesB[#valuesB] or 0
    local n = va - vb
    if n ~= 0 then
        return n
    else
        table.remove(valuesA)
        table.remove(valuesB)
        return self:CompareSingleByValue(valuesA, valuesB) 
    end
end

--=========================================================================
--[[
    接口函数 GetCardTypeByLaizi(cards)  主要是检查玩家出的牌各墩所能组成的最大牌型
    接口函数 CompareCardsLaizi(type1, type2, values1, values2)  主要用来比牌，判断大小

    这两个函数一般都是结合在一起用
--]]
--=========================================================================
--玩家出牌检查 对外接口
function LibNormalCardLogic:GetCardTypeByLaizi(cards)
    -- LOG_DEBUG("LibNormalCardLogic:GetCardTypeByLaizi....#cards:%d", #cards)
    local tempCards = Array.Clone(cards)
    local normalCards = {}
    local laiziCards = {}
    for _, v in ipairs(tempCards) do
        local nValue = GetCardValue(v)
        if LibLaiZi:IsLaiZi(nValue) then
            table.insert(laiziCards, v)
        else
            table.insert(normalCards, v)
        end
    end

    local bSuc = false
    local tempValues = {}

    local cardType = GStars_Normal_Type_SSS.PT_SINGLE
    local values = {}

    local nLaiziCount = #laiziCards
    if #tempCards == 3 then
        bSuc, tempValues = self:GetCardsAndTypeThree_Laizi(normalCards, nLaiziCount)
    elseif #tempCards == 5 then
        bSuc, tempValues = self:GetCardsAndTypeFive_Laizi(normalCards, nLaiziCount)
    end
    -- LOG_DEBUG("LibNormalCardLogic:GetCardTypeByLaizi....bSuc:%s, tempValues:%s\n", tostring(bSuc), vardump(tempValues))

    if bSuc then
        --获取最大牌型--从小到大tempValues[牌型]= { {},{},...,{}}
        for i=GStars_Normal_Type_SSS.PT_SIX, GStars_Normal_Type_SSS.PT_SINGLE, -1 do
            if tempValues[i] then
                cardType = i
                local nLen = #tempValues[i]
                -- LOG_DEBUG("LibNormalCardLogic:GetCardTypeByLaizi...cardType:%d, nLen:%d", cardType, nLen)
                values = Array.Clone(tempValues[i][nLen])
                -- LOG_DEBUG("LibNormalCardLogic:GetCardTypeByLaizi...valuesSRC:%s\n, valuesDST:%s\n", vardump(tempValues[i][nLen]), vardump(values))
                break
            end
        end
    else
        LOG_ERROR("======ERROR, GetCardTypeByLaizi:%s", TableToString(tempCards))
        bSuc = true
        cardType = GStars_Normal_Type_SSS.PT_SINGLE
        values = {}
        for _, v in ipairs(tempCards) do
            table.insert(values, GetCardValue(v))
        end
    end

    -- LOG_DEBUG("222222222GetCardTypeByLaizi....bSuc:%s, cardType:%d values:%s\n", tostring(bSuc), cardType, vardump(values))
    
    return bSuc, cardType, values
end

--自比，判断相公<注意：头墩type1和中墩type2；头墩type1和尾墩墩type2；中墩type1和尾墩墩type2 >
function LibNormalCardLogic:CompareCardsLaizi(type1, type2, values1, values2)
    if type1 == type2 then
        local valuesA = Array.Clone(values1)
        local valuesB = Array.Clone(values2)
        self:Sort_By_Value(valuesA)
        self:Sort_By_Value(valuesB)

        if type1 == GStars_Normal_Type_SSS.PT_ONE_PAIR then
            local p1 = self:GetPairValueByValue(valuesA)
            local p2 = self:GetPairValueByValue(valuesB)
            if p1 ~= p2 then
                return p1 - p2
            end

        elseif type1 == GStars_Normal_Type_SSS.PT_TWO_PAIR then
            --先比较大对子，大对子相等比较小对子
            local pa1, pb1 = self:GetPairValueByValue(valuesA)
            local pa2, pb2 = self:GetPairValueByValue(valuesB)
            local n = pb1 - pb2
            if n == 0 then
                n = pa1 - pa2
            end
            if n ~= 0 then
                return n
            end
            
        -- elseif type1 == GStars_Normal_Type_SSS.PT_THREE_GHOST
        --     or type1 == GStars_Normal_Type_SSS.PT_THREE_TWO
        --     or type1 == GStars_Normal_Type_SSS.PT_THREE_THREE then
        --     --前墩 特殊3条比较
        --     local p1 = valuesA[1]
        --     local p2 = valuesB[1]
        --     return p1 - p2

        elseif type1 == GStars_Normal_Type_SSS.PT_THREE
            or type1 == GStars_Normal_Type_SSS.PT_FULL_HOUSE
            or type1 == GStars_Normal_Type_SSS.PT_FOUR  --xxxx+y 222/333+xy
            or type1 == GStars_Normal_Type_SSS.PT_FIVE  --xxxxx 2222/3333+x
            then
            --只需要比较有三张相同的牌就行
            local p1 = self:GetSameValue(valuesA, 3)
            local p2 = self:GetSameValue(valuesB, 3)
            if p1 ~= p2 then
                return p1 - p2
            end

        elseif type1 == GStars_Normal_Type_SSS.PT_SIX then
            --22222/33333
            local p1 = valuesA[1]
            local p2 = valuesB[1]
            return p1 - p2

        elseif type1 == GStars_Normal_Type_SSS.PT_FLUSH then
            --比较对同花
            local pa1, pb1 = self:GetPairValueByValue(valuesA)
            local pa2, pb2 = self:GetPairValueByValue(valuesB)
            --先比大对子  再比小对 最后比单张大小
            local n = pb1 - pb2
            if n == 0 then
                n = pa1 - pa2
            end
            -- LOG_DEBUG("flush compare,  n= %d", n)
            if n ~= 0 then
                return n
            end 
        end
        --比单张
        return self:CompareSingleByValue(valuesA, valuesB)
    
    --特殊情况比较(头墩是对鬼冲前 中墩是三条)
    elseif type1 == GStars_Normal_Type_SSS.PT_THREE_GHOST 
			or type1 == GStars_Normal_Type_SSS.PT_THREE_TWO
			or type1 == GStars_Normal_Type_SSS.PT_THREE_THREE then
        if type2 == GStars_Normal_Type_SSS.PT_THREE then
            local valuesA = Array.Clone(values1)
            local valuesB = Array.Clone(values2)
            self:Sort_By_Value(valuesA)
            self:Sort_By_Value(valuesB)

            local p1 = valuesA[1]
            local p2 = self:GetSameValue(valuesB, 3)
            if p1 ~= p2 then
                return p1 - p2
            else
                --鬼鬼4 < 444+xy
                return -1
            end
        else
            return type1 - type2
        end

    else
        return type1 - type2
    end
end

--和别人比，判断大小
function LibNormalCardLogic:CompareCardsLaizi_other(type1, type2, values1, values2)
    if type1 == type2 then
        local valuesA = Array.Clone(values1)
        local valuesB = Array.Clone(values2)
        self:Sort_By_Value(valuesA)
        self:Sort_By_Value(valuesB)

        if type1 == GStars_Normal_Type_SSS.PT_ONE_PAIR then
            local p1 = self:GetPairValueByValue(valuesA)
            local p2 = self:GetPairValueByValue(valuesB)
            if p1 ~= p2 then
                return p1 - p2
            end

        elseif type1 == GStars_Normal_Type_SSS.PT_TWO_PAIR then
            --先比较大对子，大对子相等比较小对子
            local pa1, pb1 = self:GetPairValueByValue(valuesA)
            local pa2, pb2 = self:GetPairValueByValue(valuesB)
            local n = pb1 - pb2
            if n == 0 then
                n = pa1 - pa2
            end
            if n ~= 0 then
                return n
            end
         
        elseif type1 == GStars_Normal_Type_SSS.PT_THREE_GHOST
            or type1 == GStars_Normal_Type_SSS.PT_THREE_TWO
            or type1 == GStars_Normal_Type_SSS.PT_THREE_THREE then
            --前墩 特殊3条比较
            local p1 = valuesA[1]
            local p2 = valuesB[1]
            return p1 - p2

        elseif type1 == GStars_Normal_Type_SSS.PT_THREE
            or type1 == GStars_Normal_Type_SSS.PT_FULL_HOUSE
            or type1 == GStars_Normal_Type_SSS.PT_FOUR  --xxxx+y 222/333+xy
            or type1 == GStars_Normal_Type_SSS.PT_FIVE  --xxxxx 2222/3333+x
            then
            --只需要比较有三张相同的牌就行
            local p1 = self:GetSameValue(valuesA, 3)
            local p2 = self:GetSameValue(valuesB, 3)
            if p1 ~= p2 then
                return p1 - p2
            end

        elseif type1 == GStars_Normal_Type_SSS.PT_SIX then
            --22222/33333
            local p1 = valuesA[1]
            local p2 = valuesB[1]
            return p1 - p2

        elseif type1 == GStars_Normal_Type_SSS.PT_FLUSH then
            --比较对同花
            local pa1, pb1 = self:GetPairValueByValue(valuesA)
            local pa2, pb2 = self:GetPairValueByValue(valuesB)
            --先比大对子  再比小对 最后比单张大小
            local n = pb1 - pb2
            if n == 0 then
                n = pa1 - pa2
            end
            -- LOG_DEBUG("flush compare,  n= %d", n)
            if n ~= 0 then
                return n
            end 
        end
        --比单张
        return self:CompareSingleByValue(valuesA, valuesB)
    else
        return type1 - type2
    end
end

return LibNormalCardLogic