local base = require("logic/mahjong_sys/components/mode_2/comp_mjPlayer")
local comp_mjSelfPlayer = class("comp_mjSelfPlayer", base)


function comp_mjSelfPlayer:ctor()
	self.curClickMJItem = nil
    self.curReqOutItem = nil --当前请求出牌的牌
    self.curDragItem = nil
    self.curScrollItem = nil  -- 手指滑动时 当前选中item

    self.canOutCard = false
    self.showDisableCards = false
    self.filterCards = {}

    -- 手指滑动时 当前选中item
    self.curScrollItem = nil
	base.ctor(self)
	self:RegisterEvents()
end

function comp_mjSelfPlayer:RegisterEvents()
	InputManager.AddLock()
    Notifier.regist(cmdName.MSG_MOUSE_BTN_UP, slot(self.OnMouseUp, self))
    Notifier.regist(cmdName.MSG_MOUSE_BTN, slot(self.OnMouseBtn, self))
end

function comp_mjSelfPlayer:UnRegisterEvents()
    InputManager.ReleaseLock()
    self.shakeTimer:Uninitialize()
    Notifier.remove(cmdName.MSG_MOUSE_BTN_UP, slot(self.OnMouseUp, self))
    Notifier.remove(cmdName.MSG_MOUSE_BTN, slot(self.OnMouseBtn, self))
end


--[[--
 * @Description: 显示可听牌箭头  
 ]]
function comp_mjSelfPlayer:ShowTingInHand() 
    for i = 1, #self.handCardList do
        if roomdata_center.CheckCardTing(self.handCardList[i].paiValue) and not self.handCardList[i].isDisable then
            self.handCardList[i]:SetTingIcon(true)
        end
    end
end

--[[--
 * @Description: 隐藏可听牌箭头  
 ]]
function comp_mjSelfPlayer:HideTingInHand()
      for i = 1, #self.handCardList do
        self.handCardList[i]:SetTingIcon(false)
    end
end

--[[--
 * @Description: 麻将点击事件  
 ]]
function comp_mjSelfPlayer:ClickCardEvent( mj )
    if mj == self.curClickMJItem then       
        if self.canOutCard then
            local paiVal = mj.paiValue
            Trace("-----------ClickCardEvent paiVal"..paiVal) 
            if self:CheckCanSendOut(paiVal)or mj.isDisable==false  then
                self.curReqOutItem = mj 
                if roomdata_center.isShowGive==false then
                    for i=1,#self.ShowFourCardT do
                        if mj.paiValue==self.ShowFourCardT[i] then 
                            roomdata_center.sindex=i
                        end
                    end
                end
                mahjong_play_sys.OutCardReq(paiVal,roomdata_center.tingType)
                if self.viewSeat == 1 then
                    self:AutoOutCard(paiVal)
                end
            end
        else
            ui_sound_mgr.PlaySoundClip(mahjong_path_mgr.GetMjCommonSoundPath("audio_card_click"))
        end       
    else
        --检测如果为特殊牌型则提示不能打出
        if roomdata_center.CheckIsSpecialCard(mj.paiValue) and not self.cfg.specialCardCanSend then                
            Notifier.dispatchCmd(cmdName.MSG_MJ_OUT_WARNING)
            return 
        end          
        ui_sound_mgr.PlaySoundClip(mahjong_path_mgr.GetMjCommonSoundPath("audio_card_click"))
        for i = 1, #self.handCardList do
            self.handCardList[i]:SetSelectState(false)
        end
        self.curClickMJItem = mj
        self.curClickMJItem:SetSelectState(true)
        mode_manager.GetCurrentMode():GetComponent("comp_playerMgr"):SetHighLight(self.curClickMJItem.paiValue)
    end
end


function comp_mjSelfPlayer:CancelClick()
    if self.curClickMJItem~=nil then
        if not self.curClickMJItem.isDrag then
            self.curClickMJItem:SetSelectState(false)
        end
        self.curClickMJItem = nil
    end
end

function comp_mjSelfPlayer:AutoOutCard(paiValue) 
    mahjong_ui.cardShowView:Hide()
    self:HideTingInHand()
    self:SetCanOut(false,self.filterCards)
    roomdata_center.selfOutCard = paiValue 
    local compPlayerMgr = self.mode:GetComponent("comp_playerMgr")
    local compResMgr = self.mode:GetComponent("comp_resMgr")
    compPlayerMgr:HideHighLight()
    local isShow=nil
    if #self.ShowFourCardT==4 then
        isShow=true
    elseif #self.ShowFourCardT<=3 and #self.ShowFourCardT>=0 and roomdata_center.gamesetting.bShowGive==true then
        isShow=false
    end 
    self:OutCard(paiValue, function(pos) compResMgr:SetOutCardEfObj(pos) end,isShow)
    ui_sound_mgr.PlaySoundClip(mahjong_path_mgr.GetMjCommonSoundPath("audio_card_out"))
    --ui_sound_mgr.PlaySoundClip(mahjong_path_mgr.GetMjSoundPath(paiValue))
end


--[[--
 * @Description: 麻将拖动事件  
 ]]
function comp_mjSelfPlayer:DragCardEvent(mj)
    --检测如果为特殊牌型则提示不能打出
    if roomdata_center.CheckIsSpecialCard(mj.paiValue) and not self.cfg.specialCardCanSend then                
        Notifier.dispatchCmd(cmdName.MSG_MJ_OUT_WARNING)
        return 
    end 
    if self.curClickMJItem~=nil and self.curClickMJItem~=mj then
        self.curClickMJItem:OnClickUp()
    end
    if self.canOutCard then
        local paiVal = mj.paiValue 
        if self:CheckCanSendOut(paiVal)or mj.isDisable==false then
            self.curReqOutItem = mj
            if roomdata_center.isShowGive==false then
                for i=1,#self.ShowFourCardT do
                    if mj.paiValue==self.ShowFourCardT[i] then 
                        roomdata_center.sindex=i
                    end
                end
            end
            mahjong_play_sys.OutCardReq(paiVal,roomdata_center.tingType)
            if self.viewSeat == 1 then
                self.filterCards = nil
                self:RefreshHandCardDisable()
                self:AutoOutCard(paiVal)
            end
        end
    end
end

--[[--
 * @Description: 设置是否能出牌  
 ]]
function comp_mjSelfPlayer:SetCanOut(isCanCout, filterCards) 
    self.canOutCard = isCanCout
    self.filterCards = filterCards
    self:RefreshHandCardDisable()   
end
function comp_mjSelfPlayer:SetOutStatus(isCanCout)
    self.canOutCard = isCanCout
end
function comp_mjSelfPlayer:SetDisableCardShow(state)
    self.showDisableCards = state
end

function comp_mjSelfPlayer:RefreshHandCardDisable() 
    if self.showDisableCards then   
        local map = {}  
        if self.filterCards ~= nil then
            for k,v in pairs(self.filterCards) do  
                map[v] = 1            
            end
        end   
        if roomdata_center.gamesetting.bShowGive==true then--亮四打一
            if roomdata_center.isShowGive==false then --未打一  
               for i = 1, #self.handCardList do
                    if map[self.handCardList[i].paiValue] ~= nil  then   
                        self.handCardList[i]:SetDisable(true)    
                    elseif self.handCardList[i].isSpecialCard then
                        self.handCardList[i]:SetDisable(false) 
                    else
                        self.handCardList[i]:SetDisable(true) 
                    end
               end  
            else--已打一  
                for i = 1, #self.handCardList do 
                    if map[self.handCardList[i].paiValue] ~= nil then    
                        self.handCardList[i]:SetDisable(true)  
                    elseif self.handCardList[i].isSpecialCard then  
                        self.handCardList[i]:SetDisable(true) 
                    else  
                        self.handCardList[i]:SetDisable(false) 
                    end
                end 
            end
        else  
            for i = 1, #self.handCardList do
                if map[self.handCardList[i].paiValue] ~= nil then   
                    self.handCardList[i]:SetDisable(true)  
                else   
                    self.handCardList[i]:SetDisable(false) 
                end
            end 
        end
    end 
end

function comp_mjSelfPlayer:CheckCanSendOut(paiValue)
    if self.filterCards == nil then
        return true
    end
    for i = 1, #self.filterCards do
        if self.filterCards[i] == paiValue then
            return false
        end
    end
    return true
end

------------------------  重写 --------------------

function comp_mjSelfPlayer:Init()
	base.Init(self)
	self.canOutCard = false
	self.filterCards = {}
    self.showDisableCards = false
    self.shakeTimer = require("logic/mahjong_sys/components/base/comp_shakeTimer"):create()
end

function comp_mjSelfPlayer:OnMjAddHand(mj)
    mj.onClickCallback = slot(self.ClickCardEvent, self)
    mj.dragEvent = function( mj )
        self:DragCardEvent( mj )
    end            
    if mj.paiValue ~= nil then
        roomdata_center.AddMj(mj.paiValue)
    end
end

function comp_mjSelfPlayer:OnSortMj(mj)
    mj.canClick = true
    mj.onClickCallback = slot(self.ClickCardEvent, self)
end

function comp_mjSelfPlayer:SortHandWithAnim(notIncludeLast)
    local needAdjuct = true
    local lastMJ = self.handCardList[#self.handCardList]
    self.InsertSort(self.handCardList,notIncludeLast and self:IsRoundSendCard(#self.handCardList))
    if not self.cfg.specialNotSort then
        self:PutFrontSpecialCard(self.handCardList)
    end
    local needInsertAnim = false
    if lastMJ ~= self.handCardList[#self.handCardList] then
        needInsertAnim = true
    end
    for i=1,#self.handCardList do
        local x = self:GetHandPosX(i)
        local mj = self.handCardList[i]
        if mj == lastMJ and needInsertAnim then
            needAdjuct = false
            self:DoSortLastHandCardAnim(mj, x)
        else
            mj.transform.localPosition = Vector3(x, 0, 0)
            mj:DOLocalRotate(nil, 0,0, 0)
            mj:ShowShadow()
        end
    end
    return needAdjuct
end


function comp_mjSelfPlayer:OutCard(paiValue, callback,isShowGive)
    if self.curDragItem ~= nil then
        self.curDragItem.isDrag = false
        self.curDragItem = nil
    end
    ui_sound_mgr.PlaySoundClip(mahjong_path_mgr.GetMjSoundPath(paiValue))
    self.handCardCount = self.handCardCount - 1
    local isOut = false
    local outIndex = -1
    for i = 1, #self.handCardList, 1  do
    	if self.handCardList[i].paiValue == paiValue then
    		outIndex = i
    		if self.curReqOutItem ~= nil and self.curReqOutItem == self.handCardList[i] then
    			break
    		end
    	end
    end 
    local outMj = self.handCardList[outIndex]
    if outMj ~= nil then    
    	self.curReqOutItem = nil
        self.curClickMJItem = nil 
    	table.remove(self.handCardList,outIndex) 
        self:DoOutCard(outMj, callback)
    end
    if isShowGive~=nil then 
       if isShowGive==true then 
            for i=1,#self.ShowFourCardT do
                if self.ShowFourCardT[i]==paiValue then  
                     roomdata_center.isShowGive=true
                     table.remove(self.ShowFourCardT,i)
                     break
                end
            end
            if roomdata_center.IsPlayerTing(self.viewSeat) then
               self:SetCanOut(false,self.handCardList)
            end  
        end 
    end
    self:RefreshHandCardDisable()
    
    
end

function comp_mjSelfPlayer:OnResetHandCard(mj, value)
    mj:SetMesh(value)

    mj.onClickCallback = slot(self.ClickCardEvent, self)

    mj.dragEvent = function( mj )
        self:DragCardEvent( mj )
    end            
    roomdata_center.AddMj(mj.paiValue)    
end




-------- 点击事件相关  -----------------------

function comp_mjSelfPlayer:OnMouseUp(pos)
    if self.curDragItem ~= nil and self.curDragItem.isDrag  then
        if pos.y > Screen.height/4 then
            self:DragCardEvent( self.curDragItem )
        end
        if self.curDragItem ~= nil then
            self.curDragItem.isDrag = false
            self.curDragItem = nil
        end
        self:TidyHandCard()
        -- 松手时清除当前选中item
        if self.curClickMJItem ~= nil then
            self.curClickMJItem:SetSelectState(false)
            self.curClickMJItem = nil
        end
        return
    end

    local mj = self:GetRaycastMjItem(pos)
    if mj ~= nil then
        mj:OnClick()
    else      
        self:CancelClick()
        mode_manager.GetCurrentMode():GetComponent("comp_playerMgr"):HideHighLight()
    end
    if self.curDragItem ~= nil then
        self.curDragItem.isDrag = false
        self.curDragItem = nil
    end

    if self.curScrollItem ~= nil then
        --- 不需要修改选中状态
        self.curScrollItem = nil
    end

    for i = 1, #self.handCardList do
        self.handCardList[i].isDrag = false
    end

    if self.curClickMJItem == nil then
        for i = 1, #self.handCardList do
            self.handCardList[i]:SetSelectState(false)
        end
    end

end

-- 处理拖拽事件
function comp_mjSelfPlayer:OnMouseBtn(pos)
    local mj = self:GetRaycastMjItem(pos)
    if mj ~= nil and not mj:CheckCanClick() then
        return
    end 
   --[[ if mj~=nil then
        local m=GameObject.Instantiate(mj.transform.gameObject)
        m.transform.parent=mj.transform.parent
        m.transform.localPosition=mj.transform.localPosition
        m.transform.localEulerAngles =mj.transform.localEulerAngles 
    end]]
    if mj ~= nil and (self.curDragItem == nil or self.curDragItem.isDrag == false) then
        self.curDragItem = mj
        self:OnFingerScrollItem(mj)
    end

    if self.limitScreenPos == nil then
        self.limitScreenPos = self:GetLimitScreenPos()
    end
    if self.limitScreenPos == nil or self.curDragItem == nil then
        return
    end
    if pos.y > self.limitScreenPos.y or self.curDragItem.isDrag then
        -- z在桌子之前就行
        pos.z = 1
        local worldPos = self.camera2D:ScreenToWorldPoint(pos)
        self.curDragItem.isDrag = true
        self.curDragItem.transform.position = worldPos 
        --m.transform.position = worldPos
        mode_manager.GetCurrentMode():GetComponent("comp_playerMgr"):SetHighLight(self.curDragItem.paiValue)
    end
end

function comp_mjSelfPlayer:OnFingerScrollItem(mj)
    if mj == self.curScrollItem then
        return
    end
    if not mj:CheckCanClick() then
        return
    end

    if self.curClickMJItem ~= nil and mj ~= self.curClickMJItem then
        self.curClickMJItem:SetSelectState(false)
        self.curClickMJItem = nil
    end
    if self.curScrollItem ~= nil then
        self.curScrollItem:SetSelectState(false)
    end
    self.curScrollItem = mj
    self.curScrollItem:SetSelectState(true)
    ui_sound_mgr.PlaySoundClip(mahjong_path_mgr.GetMjCommonSoundPath("audio_card_click"))
end


function comp_mjSelfPlayer:GetLimitScreenPos()
    return Vector3(Screen.width, Screen.height / 5, 0)
end


function comp_mjSelfPlayer:GetRaycastMjItem(pos)
    local ray = self.camera2D:ScreenPointToRay(pos)
    if ray == nil then
        return
    end
    local rayHits = Physics.RaycastAll(ray, 100, 288)

    local rayhit
    if rayHits.Length > 0 then
        for i = 0, rayHits.Length - 1 do
            if rayHits[i].collider.gameObject.layer == 5 and  rayHits[i].collider.gameObject.name ~= "mask" then
                    return nil
            elseif rayHits[i].collider.gameObject.name ~= "mask" then
                rayhit = rayHits[i]
            end
        end
        if rayhit == nil then
            return
        end
        local tempObj = rayhit.collider.gameObject
        if tempObj.name == "mjobj" then
            if self.comp_mjItemMgr == nil then
                self.comp_mjItemMgr =  mode_manager.GetCurrentMode():GetComponent("comp_mjItemMgr")
            end
            local mjItem = self.comp_mjItemMgr.mjObjDict[tempObj.transform.parent.gameObject]
            if(mjItem~=nil)and mjItem.isDisable==false then
                return mjItem
            end
        end
    end

    return nil
end

function comp_mjSelfPlayer:StartShakeTimer(time,loopTime)
    self.shakeTimer:StartTimer(time,loopTime)
end

function comp_mjSelfPlayer:StopShakeTimer()
    self.shakeTimer:StopTimer()
end

function comp_mjSelfPlayer:Uninitialize()
	base.Uninitialize(self)
	self:UnRegisterEvents()
end


return comp_mjSelfPlayer