player_component = {}

function player_component.create()
	require "logic/shisangshui_sys/mode_comp_base"
	require "logic/shisangshui_sys/resMgr_component"
	require "logic/shisangshui_sys/card_define"
	local this = mode_comp_base.create()
	this.Class = player_component
	this.name = "player_component"
	
	this.playerObj = nil --Íæ¼Ò¶ÔÏó
	this.viewSeat = -1		--×øÎ»
	this.CardList = {}		--ÊÖÅÆ¶ÔÏó
	
	this.compareResult = {} --±ÈÅÆÊý¾Ý
	this.compareScores = {}
	this.base_init = this.Initialize
	this.Group1 = nil
	this.Group2 = nil
	this.Group3 = nil
	this.resMgrComponet = nil
	this.CardOrgineTrans = {}
	this.usersdata = nil
	this.cardCount = 13
	this.pokerPool = nil
	local mrOrigDic = {}

	function this:Initialize()
		this.base_init()
	end
	
	function this:InitCard()
		local cards = this.playerObj.transform:GetComponentsInChildren(typeof(UnityEngine.BoxCollider))
		if cards ~= nil then 
		--	logError("cards.Length:"..tostring(cards.Length))
			for j = 0, cards.Length -1 do
				local cardObj = cards[j]
				table.insert(this.CardList, cardObj)
			
				local cardPosition = cardObj.transform.localPosition
				local cardRotation = cardObj.transform.localRotation
				local cardScale = cardObj.transform.localScale
				local cardTrans = {}
				cardTrans.cardPosition = cardPosition
				cardTrans.cardRotation = cardRotation
				cardTrans.cardScale = cardScale
				table.insert(this.CardOrgineTrans,cardTrans)
			end
		end
	end
	
	--翻牌
	function this:PlayerGroupCard(group)
		local groupTrans =	this.playerObj.transform:FindChild(group)
		
	--	local cards = groupTrans.transform:GetComponentsInChildren(typeof(UnityEngine.MeshFilter))
		local cardsBoxColider = groupTrans.transform:GetComponentsInChildren(typeof(UnityEngine.BoxCollider))
--		Trace("PlayFirstGroupCard"..tostring(cards.Length))
	
	--	for j = 0, cards.Length -1 do
		for j = 0, cardsBoxColider.Length -1 do	
			local cardObj = cardsBoxColider[j]
			
			--[[if componentGet(cardsBoxColider[j].transform, "MeshFilter").sharedMesh.name == "heart8" and room_data.GetSssRoomDataInfo().isChip then				
				local meshRender = componentGet(cardsBoxColider[j].transform, "MeshRenderer")
				local originMatInfo = {}
				originMatInfo.meshRender = meshRender
				originMatInfo.sharedMaterial = meshRender.sharedMaterial
				table.insert(mrOrigDic, originMatInfo)				
				if meshRender ~= nil then
					local highLightMatTbl = this.resMgrComponet.GetHighLightMat()
					LuaHelper.AddMatToMeshRenderer(meshRender, highLightMatTbl.mat1, highLightMatTbl.mat2)					 
				end
			end--]]
			this.SetMaPaiMaterial(cardsBoxColider[j].transform)
			local y = cardObj.transform.localRotation.eulerAngles.y
			cardObj.transform:DOLocalRotate(Vector3(0, y, 0), 0.05, DG.Tweening.RotateMode.Fast)

			--组牌放大处理(To Do)
		--	cardObj.transform:DOScale(Vector3(2, 2, 2), 0.6):SetEase(DG.Tweening.Ease.OutBounce):OnComplete(function ()
		--		cardObj.transform:DOScale(Vector3.one, 0.2)
		--	end)			
		end
	end
	
	function this.SetMaPaiMaterial(tran)
		if room_data.GetSssRoomDataInfo().isChip and tran.name == "40(Clone)" then	
	
			local rotationZ = tran.localRotation.eulerAngles.z
				local dipai = child(tran,"dipai")
				local meshRender = componentGet(dipai, "MeshRenderer")
				local originMatInfo = {}
				originMatInfo.meshRender = meshRender
				originMatInfo.sharedMaterial = meshRender.sharedMaterial
				codeMaterial = originMatInfo
				if meshRender ~= nil then
					local highLightMatTbl = this.resMgrComponet.GetHighLightMat()
					LuaHelper.AddMatToMeshRenderer(meshRender, highLightMatTbl.mat1, highLightMatTbl.mat2)					 
				end
		end
		
	end

	--获取第一墩牌
	function this:showFirstCardByType()
		local dataTable = {}
		local cardTable = {}
		local cardType = this.compareResult["nFirstType"]
		if tonumber(cardType) > 0 then
			local stCards = this.compareResult["stCards"]
			if stCards == nil or #stCards < 1 then return end
			for i = 1 ,#stCards do

				if i > 10 and i < 14 then
					table.insert(cardTable,stCards[i])
				end
			end
			dataTable.cardTable = cardTable
			dataTable.type = cardType
			dataTable.chairid = this.viewSeat
			dataTable.index = 1
			local position = this.playerObj.transform:FindChild("2d_card_point").transform.position
			dataTable.nguiPosition = Utils.WorldPosToScreenPos(position)
			return dataTable
		end
	end

	--获取第二墩牌
	function this:showSecondCardByType()
		local dataTable = {}
		local cardTable = {}
		local cardType = this.compareResult["nSecondType"]
		if tonumber(cardType) > 0 then
			local stCards = this.compareResult["stCards"]
			if stCards == nil or #stCards < 1 then return end
			for i = 1 ,#stCards do
				if i > 5 and i < 11 then
					table.insert(cardTable,stCards[i])
				end
			end
			dataTable.cardTable = cardTable
			dataTable.type = cardType
			dataTable.chairid = this.viewSeat
			dataTable.index = 2
			local position = this.playerObj.transform:FindChild("2d_card_point").transform.position
			dataTable.nguiPosition = Utils.WorldPosToScreenPos(position)
			return dataTable
		end
	end

	--获取第三墩牌
	function this:showThreeCardByType()
		local dataTable = {}
		local cardTable = {}
		local cardType = this.compareResult["nThirdType"]
	--	local chairid = this.compareResult["chairid"]
		if tonumber(cardType) > 0 then
			local stCards = this.compareResult["stCards"]
			if stCards == nil or #stCards < 1 then return end
			for i = 1 ,#stCards do
				if i > 0 and i < 6 then
					table.insert(cardTable,stCards[i])
				end
			end
			dataTable.cardTable = cardTable
			dataTable.type = cardType
			dataTable.chairid = this.viewSeat
			dataTable.index = 3
			local position = this.playerObj.transform:FindChild("2d_card_point").transform.position
			dataTable.nguiPosition = Utils.WorldPosToScreenPos(position)
			return dataTable
		end
	end

	--获取打枪列表
	function this:GetMyShootingList()
		local chairid = this.compareResult["chairid"]
		if this.isMe then
			local shootList = this.compareResult["stShoots"]
			if shootList ~= nil then
				return shootList
			end
		end
		return nil
	end

	--设置材质
	function this:SetCardMesh(cards)
		
		if this.compareResult == nil then
			Trace("SetCard Mesh Error")
		end
		local stCards = cards
		if cards == nil then
			stCards = this.compareResult["stCards"]
			if stCards == nil or #stCards < 1 then return end
		end
		local newCardList = {}
		local cacheCards = this.pokerPool:GetCard(this.viewSeat,stCards)
		for i,card in ipairs(cacheCards) do
			card.transform.position = this.CardList[i].transform.position
			card.transform.localScale = this.CardList[i].transform.localScale
			card.transform.localRotation = this.CardList[i].transform.localRotation
			card.transform.parent = this.CardList[i].transform.parent
			card.gameObject:SetActive(true)
			table.insert(newCardList,card)
			--logError("rotationZ:"..tostring(card.transform.localEulerAngles.z))
			local rotationZ = card.transform.localEulerAngles.z
			if rotationZ  > -1 and rotationZ < 1 then
				this.SetMaPaiMaterial(card.transform)
			end
		end
		
		this.pokerPool:Recycle(this.CardList)
		
		this.CardList = {}
		this.CardList = newCardList
		
	end
	

	
	--理牌
	function this:shuffle(callback)
		local xoffset = 0
		local yoffset = 0
		xoffset =  -13 /4
		for k,cardObj in pairs(this.CardList) do
			cardObj.transform.parent.parent = this.playerObj.transform
			cardObj.transform.parent.localPosition = Vector3(xoffset,yoffset,0)
			cardObj.transform.parent.localEulerAngles = Vector3(0,0,0)
			cardObj.transform.localPosition = Vector3(0,0,0)
			cardObj.transform.localEulerAngles = Vector3(0,0,180)
			cardObj.gameObject:SetActive(false)
			xoffset = xoffset + 0.5
			yoffset = yoffset + 0.01
			this.ReSetMaPaiMaterial(cardObj.transform)
		end
		
		Trace("CardList"..tostring(#this.CardList))
		coroutine.start(function()
			for k,vv in pairs(this.CardList) do
				vv.gameObject:SetActive(true)
				coroutine.wait(0.005)
			end

			if callback ~= nil then 
				callback()
			end	
		end)
	end
	
	function this.ShowAllCard(rotateZ)
		this:CardRest(this.CardOrgineTrans)
		rotateZ = tonumber(rotateZ)
		local group3 = this.playerObj.transform:FindChild("Group3")
		this:ShowCardShanXing(group3,1,rotateZ)
		local group2 = this.playerObj.transform:FindChild("Group2")
		this:ShowCardShanXing(group2,6,rotateZ)
		local group1 = this.playerObj.transform:FindChild("Group1")
		this:ShowCardShanXing(group1,11,rotateZ)
	end
	
	function this.ReSetMaPaiMaterial(tran)
		if room_data.GetSssRoomDataInfo().isChip and tran.name == "40(Clone)" then	
		
			local dipai = child(tran,"dipai")
			
			local meshRender = componentGet(dipai.transform, "MeshRenderer")
			local originMatInfo = {}
			originMatInfo.meshRender = meshRender
			originMatInfo.sharedMaterial = meshRender.sharedMaterial
			codeMaterial = originMatInfo
			--table.insert(codeMaterial, originMatInfo)				
			if meshRender ~= nil then
				local OriginalMat = this.resMgrComponet.GetOriginalMat()
				LuaHelper.AddMatToMeshRenderer(meshRender, OriginalMat.mat1,nil)					 
			end
		end 
	end
	

	--理牌动画
	function this:ShowCardShanXing(parentObj,index,rotateZ)
		local count  = index + 4
		if index == 11 then
			 count  = index + 2
		end
		
		for i = index ,count do
			local obj = this.CardList[i]
			parentObj.transform.localPosition = Vector3(0,0,0)
			obj.transform.parent.localPosition = Vector3(0,0,0)
			
			obj.transform.parent.parent = parentObj.transform
			local x = obj.transform.localRotation.eulerAngles.x
			local y = obj.transform.localRotation.eulerAngles.y
			local z = obj.transform.localRotation.eulerAngles.z
			obj.transform.localEulerAngles = Vector3(x,y,rotateZ)
			if rotateZ == 0 and this.viewSeat == 1 then
			
				this.SetMaPaiMaterial(obj.transform) --判断马牌
			end
			if rotateZ == 180 and this.viewSeat == 1 then
				this.ReSetMaPaiMaterial(obj.transform)
			end
		end 
	end

	--玩家重置
	function this:PlayerReset()
		--恢复材质球
	--[[	for i,v in pairs(mrOrigDic) do
			Trace("v.meshRender.transform---------------------"..v.meshRender.transform.name)
			if v.meshRender ~= nil then
				--v.meshRender.sharedMaterial = v.sharedMaterial
				LuaHelper.AddMatToMeshRenderer(v.meshRender, v.sharedMaterial, nil)	
			end
		end--]]
		this.playerObj:SetActive(false)
		this.compareResult = {}
		Trace("++++++++++玩家数据重置,座位号:"..tostring(this.viewSeat))
	end

	--牌重置
	function this:CardRest(transform)
		for i = 1,#this.CardList do
			local trans = transform[i]
			local card = this.CardList[i]
			card.transform.localPosition = trans.cardPosition
			card.transform.localRotation = trans.cardRotation
			card.transform.localScale = trans.cardScale
		end
	end
	
	--找到牌桌上的马牌
	function this:GetCodeCardTran(group)
		local groupTrans =	this.playerObj.transform:FindChild(group)
		local cardsBoxColider = groupTrans.transform:GetComponentsInChildren(typeof(UnityEngine.BoxCollider))
		for j = 0, cardsBoxColider.Length -1 do	
			local cardObj = cardsBoxColider[j]
		--	if room_data.GetSssRoomDataInfo().isChip and componentGet(cardsBoxColider[j].transform, "MeshFilter").sharedMesh.name == "heart8"  then		
				if room_data.GetSssRoomDataInfo().isChip and cardObj.name == "40(Clone)"  then	
				return cardsBoxColider[j].transform
			end
		end
	end
	
	--只用于获取自己三墩各自中心的屏幕坐标
	function this:GetCardGroupScreenPos()
		--:GetComponentInChildren(typeof(UnityEngine.BoxCollider))
		local group3 = this.playerObj.transform:FindChild("Group3"):FindChild("Card3"):GetComponentInChildren(typeof(UnityEngine.BoxCollider))
		local group2 = this.playerObj.transform:FindChild("Group2"):FindChild("Card3"):GetComponentInChildren(typeof(UnityEngine.BoxCollider))
		local group1 = this.playerObj.transform:FindChild("Group1"):FindChild("Card2"):GetComponentInChildren(typeof(UnityEngine.BoxCollider))
		local screenPos3 =  Utils.WorldPosToScreenPos(group3.gameObject.transform.position)
		local screenPos2 =  Utils.WorldPosToScreenPos(group2.gameObject.transform.position)
		local screenPos1 =  Utils.WorldPosToScreenPos(group1.gameObject.transform.position)
		local playerGroupPos = {}
		table.insert(playerGroupPos,screenPos1)
		table.insert(playerGroupPos,screenPos2)
		table.insert(playerGroupPos,screenPos3)
		return playerGroupPos
	end
	
	--choose_ok设置自己牌
	function this:SetSelfCardMesh(cards)
		local stCards = cards
		if cards == nil then
			local chooseCards = card_data_manage.chooseCardsTbl
			stCards = chooseCards
			if stCards == nil or #stCards < 1 then 
				logError("choose_ok设置自己牌为空")
				return 
			end
		end
		
		local newCardList = {}
		local cacheCards = this.pokerPool:GetCard(this.viewSeat,stCards)
		for i,card in ipairs(cacheCards) do
			card.transform.position = this.CardList[i].transform.position
			card.transform.localScale = this.CardList[i].transform.localScale
			card.transform.localRotation = this.CardList[i].transform.localRotation
			card.transform.parent = this.CardList[i].transform.parent
			card.gameObject:SetActive(true)
			table.insert(newCardList,card)
		end
		for i,v in ipairs(this.CardList) do 
			if v ~= nil then
				v.gameObject.transform.parent = nil
				v.gameObject:SetActive(false)
			end
		end
		this.CardList = {}
		this.CardList = newCardList
		
		
	
	end
	
	function this:SetSelfCardMeshWithGroup(group,mesh)
		local cardMeshFilterArray = group.transform:GetComponentsInChildren(typeof(UnityEngine.BoxCollider))
		for j = 0, cardMeshFilterArray.Length -1 do
			local subCardMeshFilter = cardMeshFilterArray[j].transform:GetComponent(typeof(UnityEngine.MeshFilter))
			subCardMeshFilter.mesh = mesh[j+1]
			--[[if componentGet(cardMeshFilterArray[j].transform, "MeshFilter").sharedMesh.name == "heart8" and room_data.GetSssRoomDataInfo().isChip then				
				local meshRender = componentGet(cardMeshFilterArray[j].transform, "MeshRenderer")
				local originMatInfo = {}
				originMatInfo.meshRender = meshRender
				originMatInfo.sharedMaterial = meshRender.sharedMaterial
				table.insert(mrOrigDic, originMatInfo)				
				if meshRender ~= nil then
					local highLightMatTbl = this.resMgrComponet.GetHighLightMat()
					LuaHelper.AddMatToMeshRenderer(meshRender, highLightMatTbl.mat1, highLightMatTbl.mat2)					 
				end
			end--]]
		end
	end
	
	return this
end


